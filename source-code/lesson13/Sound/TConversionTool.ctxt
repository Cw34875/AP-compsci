#BlueJ class context
comment0.params=buffer\ byteOffset\ bigEndian
comment0.target=int\ bytesToInt16(byte[],\ int,\ boolean)
comment0.text=\n\ Converts\ 2\ successive\ bytes\ starting\ at\ <code>byteOffset</code>\ in\ \n\ <code>buffer</code>\ to\ a\ signed\ integer\ sample\ with\ 16bit\ range.\n\ <p>\n\ For\ little\ endian,\ buffer[byteOffset]\ is\ interpreted\ as\ low\ byte,\n\ whereas\ it\ is\ interpreted\ as\ high\ byte\ in\ big\ endian.\n\ <p>\ This\ is\ a\ reference\ function.\n
comment1.params=buffer\ byteOffset\ bigEndian
comment1.target=int\ bytesToInt24(byte[],\ int,\ boolean)
comment1.text=\n\ Converts\ 3\ successive\ bytes\ starting\ at\ <code>byteOffset</code>\ in\ \n\ <code>buffer</code>\ to\ a\ signed\ integer\ sample\ with\ 24bit\ range.\n\ <p>\n\ For\ little\ endian,\ buffer[byteOffset]\ is\ interpreted\ as\ lowest\ byte,\n\ whereas\ it\ is\ interpreted\ as\ highest\ byte\ in\ big\ endian.\n\ <p>\ This\ is\ a\ reference\ function.\n
comment10.params=b
comment10.target=int\ unsignedByteToInt(byte)
comment10.text=\n\ Byte<->Int\ conversions\ for\ unsigned\ pcm\ data\ were\ written\n\ by\ myself\ with\ help\ from\ Real's\ Java\ How-To\:\n\ http\://www.rgagnon.com/javadetails/java-0026.html\n
comment11.params=buffer\ offset\ isBigEndian
comment11.target=int\ unsignedByteToInt16(byte[],\ int,\ boolean)
comment12.params=buffer\ offset\ isBigEndian
comment12.target=int\ unsignedByteToInt24(byte[],\ int,\ boolean)
comment13.params=buffer\ offset\ isBigEndian
comment13.target=int\ unsignedByteToInt32(byte[],\ int,\ boolean)
comment14.params=sample
comment14.target=byte\ intToUnsignedByte(int)
comment15.params=sample\ buffer\ byteOffset\ bigEndian
comment15.target=void\ intToUnsignedBytes16(int,\ byte[],\ int,\ boolean)
comment16.params=sample\ buffer\ byteOffset\ bigEndian
comment16.target=void\ intToUnsignedBytes24(int,\ byte[],\ int,\ boolean)
comment17.params=sample\ buffer\ byteOffset\ bigEndian
comment17.target=void\ intToUnsignedBytes32(int,\ byte[],\ int,\ boolean)
comment2.params=buffer\ byteOffset\ bigEndian
comment2.target=int\ bytesToInt32(byte[],\ int,\ boolean)
comment2.text=\n\ Converts\ a\ 4\ successive\ bytes\ starting\ at\ <code>byteOffset</code>\ in\ \n\ <code>buffer</code>\ to\ a\ signed\ 32bit\ integer\ sample.\n\ <p>\n\ For\ little\ endian,\ buffer[byteOffset]\ is\ interpreted\ as\ lowest\ byte,\n\ whereas\ it\ is\ interpreted\ as\ highest\ byte\ in\ big\ endian.\n\ <p>\ This\ is\ a\ reference\ function.\n
comment3.params=ulawbyte
comment3.target=short\ ulaw2linear(byte)
comment4.params=sample
comment4.target=byte\ linear2ulaw(int)
comment4.text=\n\ Converts\ a\ linear\ signed\ 16bit\ sample\ to\ a\ uLaw\ byte.\n\ Ported\ to\ Java\ by\ fb.\n\ <BR>Originally\ by\:<BR>\n\ Craig\ Reese\:\ IDA/Supercomputing\ Research\ Center\ <BR>\n\ Joe\ Campbell\:\ Department\ of\ Defense\ <BR>\n\ 29\ September\ 1989\ <BR>\n
comment5.params=ulawbyte
comment5.target=short\ alaw2linear(byte)
comment6.params=pcm_val
comment6.target=byte\ linear2alaw(short)
comment7.params=sample\ buffer\ byteOffset\ bigEndian
comment7.target=void\ intToBytes16(int,\ byte[],\ int,\ boolean)
comment7.text=\n\ Converts\ a\ 16\ bit\ sample\ of\ type\ <code>int</code>\ to\ 2\ bytes\ in\ an\ array.\n\ <code>sample</code>\ is\ interpreted\ as\ signed\ (as\ Java\ does).\n\ <p>\n\ For\ little\ endian,\ buffer[byteOffset]\ is\ filled\ with\ low\ byte\ of\ sample,\ \n\ and\ buffer[byteOffset+1]\ is\ filled\ with\ high\ byte\ of\ sample\ +\ sign\ bit.\n\ <p>\ For\ big\ endian,\ this\ is\ reversed.\n\ <p>\ Before\ calling\ this\ function,\ it\ should\ be\ assured\ that\ \n\ <code>sample</code>\ is\ in\ the\ 16bit\ range\ -\ it\ will\ not\ be\ clipped.\n\ <p>\ This\ is\ a\ reference\ function.\n
comment8.params=sample\ buffer\ byteOffset\ bigEndian
comment8.target=void\ intToBytes24(int,\ byte[],\ int,\ boolean)
comment8.text=\n\ Converts\ a\ 24\ bit\ sample\ of\ type\ <code>int</code>\ to\ 3\ bytes\ in\ an\ array.\n\ <code>sample</code>\ is\ interpreted\ as\ signed\ (as\ Java\ does).\n\ <p>\n\ For\ little\ endian,\ buffer[byteOffset]\ is\ filled\ with\ low\ byte\ of\ sample,\ \n\ and\ buffer[byteOffset+2]\ is\ filled\ with\ the\ high\ byte\ of\ sample\ +\ \n\ sign\ bit.\n\ <p>\ For\ big\ endian,\ this\ is\ reversed.\n\ <p>\ Before\ calling\ this\ function,\ it\ should\ be\ assured\ that\ \n\ <code>sample</code>\ is\ in\ the\ 24bit\ range\ -\ it\ will\ not\ be\ clipped.\n\ <p>\ This\ is\ a\ reference\ function.\n
comment9.params=sample\ buffer\ byteOffset\ bigEndian
comment9.target=void\ intToBytes32(int,\ byte[],\ int,\ boolean)
comment9.text=\n\ Converts\ a\ 32\ bit\ sample\ of\ type\ <code>int</code>\ to\ 4\ bytes\ in\ an\ array.\n\ <code>sample</code>\ is\ interpreted\ as\ signed\ (as\ Java\ does).\n\ <p>\n\ For\ little\ endian,\ buffer[byteOffset]\ is\ filled\ with\ lowest\ byte\ of\ \n\ sample,\ and\ buffer[byteOffset+3]\ is\ filled\ with\ the\ high\ byte\ of\ \n\ sample\ +\ sign\ bit.\n\ <p>\ For\ big\ endian,\ this\ is\ reversed.\n\ <p>\ This\ is\ a\ reference\ function.\n
numComments=18
